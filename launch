#!/usr/bin/env python3

import os
import stat
import re
import argparse
import subprocess
import sys

assert sys.version_info >= (3, 6), "Python >= 3.6 required"

exp_def = 2000
cutoff_def = 15
mf_def = 3

parser = argparse.ArgumentParser()
parser.add_argument('--dataset', '-d', type=str, required=True,
	help="dataset directory")
parser.add_argument('--experiments', '-e', type=int, default=exp_def,
	help="experiment cutoff time in minutes")
parser.add_argument('--cutoff', '-c', type=int, default=cutoff_def,
	help="experiment cutoff time in minutes")
parser.add_argument('--metafolds', '-m', type=int,
	choices=(1,3), default=mf_def,
	help="number of metafolds provided for bottom-level sampling")
parser.add_argument('--repeat', '-r', type=int, default=1,
	help="launch or validate n repetitions")
group = parser.add_mutually_exclusive_group()
group.add_argument('--validate', '-v', type=int,
	help="validate completed run (pass job id of run)")
group.add_argument('--integrate', '-i', type=int,
	help="integrate validation (pass job id of run)")

args = parser.parse_args()
ds = args.dataset
exp = args.experiments
cutoff = args.cutoff
mf = args.metafolds

log_name = "{}-{}f{}k{}m-irace".format(ds, mf, exp//1000, cutoff)

if not args.validate and not args.integrate:
	print("launching {}: {} experiments, {}m cutoff, {} MFs".format(
		ds, exp, cutoff, mf))
	if args.repeat > 1:
		print(args.repeat, "times")

	log_name = "{}-{}f{}k{}m-irace".format(ds, mf, exp//1000, cutoff)

	os.makedirs("output/"+ds, exist_ok=True)
	output = "output/{}/isklearn-{}-%j.out".format(ds, log_name)
	cmd = ["sbatch", "--output", output, "batch_script",
		ds] + list(map(str, [exp, cutoff, mf])) + [log_name]
	for _ in range(args.repeat):
		subprocess.run(cmd)
else:
	first_id = args.validate if args.validate else args.integrate
	val_dir = "validation/{}-{}".format(log_name, first_id)
	if args.repeat > 1:
		val_dir += "-{}".format(first_id+args.repeat-1)
		
	if args.validate:
		os.makedirs(val_dir, exist_ok=True)

		for job_id in range(first_id, first_id+args.repeat):
			# get elite configurations
			configs = []
			out_log = "output/{}/isklearn-{}-{}.out".format(
				ds, log_name, job_id)
			with open(out_log, 'r') as log_file:
				config_re = r'^\d+\s+--dataset.+'
				results = [re.findall(config_re, line) for line in log_file]
				configs = [config for result in results for config in result]
			if not configs:
				print("WARNING: No elite configs found for "+out_log)
				continue

			# generate validation script
			script_file = val_dir+"/val-script-{}".format(job_id)
			with open(script_file, 'w') as script:
				script.write("#!/bin/bash\n")
				script.write("#SBATCH --time=1-0:00\n")
				script.write("#SBATCH --cpus-per-task=1\n")
				script.write("#SBATCH --mem-per-cpu=16G\n")
				script.write("#SBATCH --array=0-{}\n".format(len(configs)-1))
				script.write("#SBATCH --job-name={}-val\n".format(log_name))
				script.write("#SBATCH --output={}/{}-{}-val-%A-%a\n".format(
					val_dir, log_name, job_id))

				script.write("\nCONFIGS=(")
				for config in configs:
					script.write("\"{}\"\n".format(config))
				script.write(")\n\n")

				val_cmd = "srun python {}/{}/validation.py".format(
					os.getcwd(), ds)
				script.write(val_cmd+" ${CONFIGS[$SLURM_ARRAY_TASK_ID]}\n")
			# make script executable
			st = os.stat(script_file)
			os.chmod(script_file, st.st_mode | stat.S_IEXEC)

			# run script
			cmd = ["sbatch", script_file]
			subprocess.run(cmd)
	else:
		best_file = "{}/{}-best.out".format(val_dir, log_name)
		open(best_file, 'w').close()

		for job_id in range(first_id, first_id+args.repeat):
			val_base = "{}-{}-val".format(
				log_name, job_id)
			val_re = re.compile(val_base + r"-\d+-\d+")
			val_files = [val_dir + "/" + f for f in filter(
				val_re.search, os.listdir(val_dir))]

			full_file = "{}/{}.out".format(val_dir, val_base)
			with open(full_file, 'w') as outfile:
			    for fname in val_files:
			        with open(fname) as infile:
			            outfile.write(infile.read())
					# os.remove(fname)

			with open(best_file, 'a') as best:
				with open(full_file, 'r') as infile:
					result_re = r'(\[[\d\.,\s]+\] ([\d\.]+)\n.+)'
					results = re.findall(result_re, infile.read())
					if not results:
						print("WARNING: No validation results in", full_file)
						continue
					best.write(sorted(results, key=lambda r: float(r[1]),
						reverse=True)[0][0] + "\n\n")
		print("Results compiled in", best_file)

